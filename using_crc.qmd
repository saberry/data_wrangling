---
title: "Parallelization and The CRC"
format:
  html:
    toc: true
    toc-location: left
    theme: vapor
    self-contained: true
---

## Making The Most of Your Machine

Your computer does not just have one core doing all the work, but has 8, 12, or maybe even 16. When you are using your computer for various tasks, it is balancing that load across the cores. If we have a compute intensive task, though, we can split that job up across the cores to speed up the job. 

Want to know how many cores your machine has available?

```{r}
parallel::detectCores()
```

Now you know how much use you can get out of your machine. 

### Using furrr and future

The base R package `parallel` is great, but requires a little bit of work to get going -- you've got to create clusters, register packages and objects, and then have a pretty solid understanding of the various apply-family functions (which you should really learn anyway). 

```{r}
rail <- read.csv("~/data_wrangling_class/data/Rail_Equipment_Accident_Incident_Data.csv")

rail$casualty <- rail$Total.Persons.Injured + rail$Total.Persons.Killed

simple_model <- lm(casualty ~ Temperature + Loaded.Freight.Cars + Minutes.Conductors.On.Duty, 
                   data = rail)

model_summary <- summary(simple_model)

t_result <- data.frame(t(model_summary$coefficients[, 't value']))
```

Now let's see how we can bootstrap in parallel.

```{r}
library(furrr)
library(future)

plan(multisession, workers = parallel::detectCores() - 1)

bootstraps <- 100

output <- future_map_dfr(1:bootstraps, ~{
  
  sample_rows <- sample(x = 1:nrow(rail), 
                        size = 10000, 
                        replace = TRUE)
  
  sample_data <- rail[sample_rows, ]
  
  simple_model <- lm(casualty ~ Temperature + Loaded.Freight.Cars + Minutes.Conductors.On.Duty, 
                     data = sample_data)
  
  model_summary <- summary(simple_model)
  
  t_result <- data.frame(t(model_summary$coefficients[, 't value']))
  
  t_result
})

plan(sequential)
```

### Using foreach

If you don't want to learn how to use R to its potential (definitely a mistake) and stick with for loops, then you can use the `foreach` package to parallelize your for loops.

```{r}
library(foreach)
library(doParallel)

cl <- makeCluster(parallel::detectCores() - 1)

registerDoParallel(cl)

foreach_bootstrap <- foreach(i = 1:bootstraps, .combine = "rbind") %dopar% {
  
  sample_rows <- sample(x = 1:nrow(rail), 
                        size = 10000, 
                        replace = TRUE)
  
  sample_data <- rail[sample_rows, ]
  
  simple_model <- lm(casualty ~ Temperature + Loaded.Freight.Cars + Minutes.Conductors.On.Duty, 
                     data = sample_data)
  
  model_summary <- summary(simple_model)
  
  t_result <- data.frame(t(model_summary$coefficients[, 't value']))
  
  t_result
}

stopCluster(cl)
```

This is great when you've got something that will fit nicely on your own machine, but you just want to experience a little more speed!

## Logging In

## Installing Packages

You already know how to install packages and it isn't much harder than that, but there are a few things that need to be done before. 

You'll need to make a directory to dump your R packages into. You can do it pretty easily by copying the following right into your CRC terminal:

```{bash}
#| eval: false
mkdir ~/myRlibs
```

To make life easier once we get into R, we also need to create an `Renviron` profile.

We will start by opening up a text editor. Just to keep things easy, we can use nano:

```{bash}
#| eval: false
nano
```

Within nano, type the following:

```{bash}
#| eval: false
R_LIBS=~/myRLibs
```

Next, you can press Ctrl + O to name and save your file. 

Once your file is saved, you can hit Ctrl + X to escape from Nano.

Finally, use head to see what is in the file:

```{bash}
#| eval: false
head .Renviron
```

::: {.callout-note}
Terminal-based text editors scare people. Nano is probably the easiest, since you start in `insert` mode. VIM, however, is probably the most famous of them all; it is likely the most powerful text editor in existence. In VIM, you need to enter into the command mode with escape. From there, you can go into `INSERT` mode with I. Once you write some stuff, you need to go back to the command prompt. From there, you can :q, :wq, or :q -- all variants of quitting and writing.
:::

Now that we have a place to dump packages, we can get R going.

```{bash}
#| eval: false
module load R
```

Now that R is loaded, you can just type R in the terminal and you will be greeted with R!

```{bash}
#| eval: false
R
```

And to something a bit more familiar:

```{r}
#| eval: false
install.packages('dplyr', 
                 lib = '~/myRLibs', 
                 repos = 'https://cloud.r-project.org')
```

You will probably find errors popping up when you are installing packages, coupled with the lack of a friendly IDE. Just keep in mind that you might have to read the error messages and install those packages that it is telling you caused a problem. 

## Submitting Jobs

To submit jobs, you'll need an R script and a bash script. 

It will contain the following information:

```{bash}
#| eval: false
#!/bin/bash 
#$ -M netid@nd.edu   # Email address for job notification
#$ -m abe             # Send mail when job begins, ends and aborts

module load R
R CMD BATCH  your_input_R_file.r  your_output_R_file.out
```

You can make it anywhere you want, but using nano is helpful here. It will have a .script extension. 

Once you have that saved, you just need to submit the job:

```{bash}
#| eval: false
qsub my_r_job.sh
```

Since we put an `abe` tag in our batch script, we will get an email when our job starts and ends (or has an error).

